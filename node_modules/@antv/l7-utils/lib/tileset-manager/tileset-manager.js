var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/tileset-manager/tileset-manager.ts
var tileset_manager_exports = {};
__export(tileset_manager_exports, {
  TilesetManager: () => TilesetManager
});
module.exports = __toCommonJS(tileset_manager_exports);
var import_eventemitter3 = __toESM(require("eventemitter3"));
var import_lodash = require("lodash");
var import_const = require("./const");
var import_tile = require("./tile");
var import_types = require("./types");
var import_bound_buffer = require("./utils/bound-buffer");
var import_lonlat_tile = require("./utils/lonlat-tile");
var TilesetManager = class extends import_eventemitter3.default {
  constructor(options) {
    super();
    this.currentTiles = [];
    this.cacheTiles = /* @__PURE__ */ new Map();
    this.throttleUpdate = (0, import_lodash.throttle)((zoom, latLonBounds) => {
      this.update(zoom, latLonBounds);
    }, 16);
    this.onTileLoad = (tile) => {
      this.emit("tile-loaded", tile);
      this.updateTileVisible();
    };
    this.onTileError = (error, tile) => {
      this.emit("tile-error", { error, tile });
      this.updateTileVisible();
    };
    this.onTileUnload = (tile) => {
      this.emit("tile-unload", tile);
    };
    this.options = {
      tileSize: 256,
      minZoom: 0,
      maxZoom: Infinity,
      zoomOffset: 0,
      extent: import_const.DEFAULT_EXTENT,
      getTileData: import_const.NOOP,
      warp: true,
      updateStrategy: import_types.UpdateTileStrategy.Overlap
    };
    this.updateOptions(options);
  }
  get isLoaded() {
    return this.currentTiles.every((tile) => tile.isDone);
  }
  get tiles() {
    const tiles = Array.from(this.cacheTiles.values()).sort((t1, t2) => t1.z - t2.z);
    return tiles;
  }
  updateOptions(options) {
    const minZoom = options.minZoom === void 0 ? this.options.minZoom : Math.ceil(options.minZoom);
    const maxZoom = options.maxZoom === void 0 ? this.options.maxZoom : Math.floor(options.maxZoom);
    this.options = { ...this.options, ...options, minZoom, maxZoom };
  }
  update(zoom, latLonBounds) {
    const verifyZoom = Math.max(0, Math.ceil(zoom));
    if (this.lastViewStates && this.lastViewStates.zoom === verifyZoom && (0, import_bound_buffer.isLatLonBoundsContains)(this.lastViewStates.latLonBoundsBuffer, latLonBounds)) {
      return;
    }
    const latLonBoundsBuffer = (0, import_bound_buffer.getLatLonBoundsBuffer)(latLonBounds, import_const.BOUNDS_BUFFER_SCALE);
    this.lastViewStates = {
      zoom: verifyZoom,
      latLonBounds,
      latLonBoundsBuffer
    };
    let isAddTile = false;
    const tileIndices = this.getTileIndices(verifyZoom, latLonBoundsBuffer).filter((tile) => {
      return this.options.warp || tile.x >= 0 && tile.x < Math.pow(2, verifyZoom);
    });
    this.currentTiles = tileIndices.map(({ x, y, z }) => {
      let tile = this.getTile(x, y, z);
      if (tile) {
        const needsReload = (tile == null ? void 0 : tile.isFailure) || (tile == null ? void 0 : tile.isCancelled);
        if (needsReload) {
          tile.loadData({
            getData: this.options.getTileData,
            onLoad: this.onTileLoad,
            onError: this.onTileError
          });
        }
        return tile;
      }
      tile = this.createTile(x, y, z);
      isAddTile = true;
      return tile;
    });
    if (isAddTile) {
      this.resizeCacheTiles();
    }
    this.updateTileVisible();
    this.pruneRequests();
  }
  reloadAll() {
    for (const [tileId, tile] of this.cacheTiles) {
      if (!this.currentTiles.includes(tile)) {
        this.cacheTiles.delete(tileId);
        this.onTileUnload(tile);
        return;
      }
      this.onTileUnload(tile);
      tile.loadData({
        getData: this.options.getTileData,
        onLoad: this.onTileLoad,
        onError: this.onTileError
      });
    }
  }
  pruneRequests() {
    const abortCandidates = [];
    for (const tile of this.cacheTiles.values()) {
      if (tile.isLoading) {
        if (!tile.isCurrent && !tile.isVisible) {
          abortCandidates.push(tile);
        }
      }
    }
    while (abortCandidates.length > 0) {
      const tile = abortCandidates.shift();
      tile.abortLoad();
    }
  }
  getTileByLngLat(lng, lat, zoom) {
    const { zoomOffset } = this.options;
    const z = Math.ceil(zoom) + zoomOffset;
    const xy = (0, import_lonlat_tile.osmLonLat2TileXY)(lng, lat, z);
    const tiles = this.tiles.filter((t) => t.key === `${xy[0]}_${xy[1]}_${z}`);
    return tiles[0];
  }
  clear() {
    for (const tile of this.cacheTiles.values()) {
      if (tile.isLoading) {
        tile.abortLoad();
      } else {
        this.onTileUnload(tile);
      }
    }
    this.lastViewStates = void 0;
    this.cacheTiles.clear();
    this.currentTiles = [];
  }
  destroy() {
    this.clear();
    this.removeAllListeners();
  }
  updateTileVisible() {
    const updateStrategy = this.options.updateStrategy;
    const beforeVisible = /* @__PURE__ */ new Map();
    for (const tile of this.cacheTiles.values()) {
      beforeVisible.set(tile.key, tile.isVisible);
      tile.isCurrent = false;
      tile.isVisible = false;
    }
    for (const tile of this.currentTiles) {
      tile.isCurrent = true;
      tile.isVisible = true;
    }
    const tiles = Array.from(this.cacheTiles.values());
    if (typeof updateStrategy === "function") {
      updateStrategy(tiles);
    } else {
      import_const.UPDATE_TILE_STRATEGIES[updateStrategy](tiles);
    }
    let isVisibleChange = false;
    Array.from(this.cacheTiles.values()).forEach((tile) => {
      if (tile.isVisible !== beforeVisible.get(tile.key)) {
        tile.isVisibleChange = true;
        isVisibleChange = true;
      } else {
        tile.isVisibleChange = false;
      }
    });
    if (isVisibleChange) {
      this.emit("tile-update");
    }
  }
  getTileIndices(zoom, latLonBounds) {
    const { tileSize, extent, zoomOffset } = this.options;
    const maxZoom = Math.floor(this.options.maxZoom);
    const minZoom = Math.ceil(this.options.minZoom);
    const indices = (0, import_lonlat_tile.getTileIndices)({
      maxZoom,
      minZoom,
      zoomOffset,
      tileSize,
      zoom,
      latLonBounds,
      extent
    });
    return indices;
  }
  getTileId(x, y, z) {
    const tileId = `${x},${y},${z}`;
    return tileId;
  }
  getTile(x, y, z) {
    const tileId = this.getTileId(x, y, z);
    const tile = this.cacheTiles.get(tileId);
    return tile;
  }
  createTile(x, y, z) {
    const tileId = this.getTileId(x, y, z);
    const tile = new import_tile.SourceTile({
      x,
      y,
      z,
      tileSize: this.options.tileSize,
      warp: this.options.warp
    });
    this.cacheTiles.set(tileId, tile);
    tile.loadData({
      getData: this.options.getTileData,
      onLoad: this.onTileLoad,
      onError: this.onTileError
    });
    return tile;
  }
  resizeCacheTiles() {
    const maxCacheSize = import_const.DEFAULT_CACHE_SCALE * this.currentTiles.length;
    const overflown = this.cacheTiles.size > maxCacheSize;
    if (overflown) {
      for (const [tileId, tile] of this.cacheTiles) {
        if (!tile.isVisible && !this.currentTiles.includes(tile)) {
          this.cacheTiles.delete(tileId);
          this.onTileUnload(tile);
        }
        if (this.cacheTiles.size <= maxCacheSize) {
          break;
        }
      }
    }
    this.rebuildTileTree();
  }
  rebuildTileTree() {
    for (const tile of this.cacheTiles.values()) {
      tile.parent = null;
      tile.children.length = 0;
    }
    for (const tile of this.cacheTiles.values()) {
      const parent = this.getNearestAncestor(tile.x, tile.y, tile.z);
      tile.parent = parent;
      if (parent == null ? void 0 : parent.children) {
        parent.children.push(tile);
      }
    }
  }
  getNearestAncestor(x, y, z) {
    while (z > this.options.minZoom) {
      x = Math.floor(x / 2);
      y = Math.floor(y / 2);
      z = z - 1;
      const parent = this.getTile(x, y, z);
      if (parent) {
        return parent;
      }
    }
    return null;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  TilesetManager
});
